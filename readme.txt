Требования к парсеру:
(done)	На вход можно передать массив байт или строку hex данных
(done)	Разборка поля 55 (пример внизу) осуществляется в отдельные объекты (data class) или кортежи (Pair<...> / Triple<...>) (далее по тексту - объект) (done)
(done, added toPare method)	Объекты, представляющие отдельные тэги состоят из 2 компонент: имя-значение
(done)	Результатом работы парсера является коллекция (массив, список, etc.) объектов
(done, to stdout)-	В целях демонстрации результата, результат парсинга выводится в терминал (stdout) или в файл в формате:
	9F02 06 000000001000, 9F03 06 000000000000, …

Желательно:
(done but not all cases, need better understanding of exception handling)	В случае возникновения ошибки парсинга, в целях отладки, выводить тэги, которые удалось распарсить + позицию последнего успешно прочитанного тэга в исходном массиве/строке
(done)	Учтен механизм расширенной длины тэга (длина занимает больше 1 байта)
(done)	Дополнить проект сборщиком 55-го поля из коллекции объектов
(done, sort of =/)	Дополнить проект юнит тестом с парсингом и сборкой набора EMV данных “туда-обратно” и автоматическим сравнением конечного результата и исходного набора
(done, but need to improve toString for pretties output)	Рекурсивный парсинг вложенных тэгов : к имени-значению объекта/кортежа добавляется опциональное поле - коллекция вложенных тегов)

to consider:
 - now works only if tag len fits into signed Int.
 - maybe need to use UInt and UByteArray everywhere, but not sure

